# OpenSpec 规范驱动开发使用指南

## 📋 目录

1. [什么是 OpenSpec](#什么是-openspec)
2. [核心概念](#核心概念)
3. [工作流程概览](#工作流程概览)
4. [命令详解](#命令详解)
5. [实战示例](#实战示例)
6. [最佳实践](#最佳实践)
7. [常见场景](#常见场景)

---

## 什么是 OpenSpec

OpenSpec 是一种**规范驱动开发（Specification-Driven Development）**方法论，通过结构化的工件（Artifacts）来指导软件开发过程。

### 核心理念

- **先规范，后实现**：在编写代码前，先创建清晰的规范文档
- **分步推进**：通过多个工件逐步细化需求和设计
- **可验证性**：实现完成后可对照规范进行验证
- **知识沉淀**：规范文档成为项目的知识资产

### 适用场景

- ✅ 新功能开发
- ✅ 复杂问题修复
- ✅ 架构重构
- ✅ 需要多人协作的任务
- ✅ 需要详细文档的项目

---

## 核心概念

### 1. Change（变更）

一个 Change 代表一次完整的开发任务，包含从需求到实现的全过程。

### 2. Artifacts（工件）

工件是 Change 过程中产生的结构化文档，典型的工件序列包括：

- **需求分析**：明确要做什么
- **技术设计**：确定如何实现
- **实现计划**：分解具体任务
- **验收标准**：定义完成标准

### 3. Delta Spec（增量规范）

针对特定 Change 的规范文档，描述相对于主规范的变更。

### 4. Main Spec（主规范）

项目的核心规范文档，汇总所有已完成的变更。

---

## 工作流程概览

```
┌─────────────────────────────────────────────────────────────┐
│                    OpenSpec 完整工作流                        │
└─────────────────────────────────────────────────────────────┘

1. 探索阶段（可选）
   └─> opsx:explore - 思考和澄清需求

2. 启动变更
   └─> opsx:new - 创建新的 Change

3. 创建工件（两种方式）
   ├─> opsx:continue - 逐步创建每个工件（推荐）
   └─> opsx:ff - 快速生成所有工件（快速模式）

4. 实施开发
   └─> opsx:apply - 根据工件实现任务

5. 验证实现
   └─> opsx:verify - 验证实现是否符合规范

6. 归档变更
   ├─> opsx:archive - 归档单个变更
   └─> opsx:bulk-archive - 批量归档多个变更

7. 同步规范（可选）
   └─> opsx:sync - 将 Delta Spec 同步到 Main Spec
```

---

## 命令详解

### 基础命令

#### `opsx:new` - 创建新变更

**用途**：启动一个新的开发任务

**使用场景**：
- 开始开发新功能
- 修复复杂 Bug
- 进行架构调整

**示例**：
```bash
/opsx:new
# 或使用完整命令
/openspec-new-change
```

**执行后**：
- 创建新的 Change 目录
- 初始化工件结构
- 进入工件创建流程

---

#### `opsx:continue` - 继续创建工件

**用途**：逐步创建下一个工件

**使用场景**：
- 完成当前工件后，创建下一个
- 需要仔细思考每个阶段的设计

**示例**：
```bash
/opsx:continue
```

**特点**：
- ✅ 逐步推进，每次专注一个工件
- ✅ 可以在每个阶段充分思考
- ✅ 适合复杂任务

---

#### `opsx:ff` - 快速生成所有工件

**用途**：一次性生成所有需要的工件

**使用场景**：
- 任务相对简单明确
- 需要快速进入实现阶段
- 已经有清晰的思路

**示例**：
```bash
/opsx:ff
```

**特点**：
- ⚡ 快速生成所有工件
- ⚠️ 可能缺少深度思考
- 适合简单任务

---

### 实施命令

#### `opsx:apply` - 实施任务

**用途**：根据工件中的任务列表进行实现

**使用场景**：
- 工件创建完成后
- 开始编写代码
- 执行具体的开发任务

**示例**：
```bash
/opsx:apply
```

**执行内容**：
- 读取实现计划中的任务
- 逐个完成任务
- 更新任务状态

---

### 验证命令

#### `opsx:verify` - 验证实现

**用途**：验证实现是否符合规范要求

**使用场景**：
- 实现完成后
- 归档前的质量检查
- 确保没有遗漏

**示例**：
```bash
/opsx:verify
```

**验证内容**：
- ✓ 所有任务是否完成
- ✓ 实现是否符合设计
- ✓ 验收标准是否满足
- ✓ 代码质量是否达标

---

### 归档命令

#### `opsx:archive` - 归档变更

**用途**：完成并归档一个 Change

**使用场景**：
- 实现和验证都完成
- 准备结束当前任务
- 需要更新主规范

**示例**：
```bash
/opsx:archive
```

**执行内容**：
- 标记 Change 为已完成
- 可选：同步到主规范
- 归档相关文档

---

#### `opsx:bulk-archive` - 批量归档

**用途**：一次性归档多个已完成的 Change

**使用场景**：
- 多个并行任务都已完成
- 批量清理已完成的变更
- 统一更新主规范

**示例**：
```bash
/opsx:bulk-archive
```

---

### 辅助命令

#### `opsx:explore` - 探索模式

**用途**：思考伙伴，用于探索想法和澄清需求

**使用场景**：
- 需求不明确时
- 需要头脑风暴
- 调查问题根因
- 在开始 Change 前理清思路

**示例**：
```bash
/opsx:explore
```

**特点**：
- 💭 自由探索和思考
- 🔍 调查和分析问题
- 📝 澄清需求和方案
- 不会创建正式工件

---

#### `opsx:sync` - 同步规范

**用途**：将 Delta Spec 同步到 Main Spec

**使用场景**：
- 需要更新主规范但不归档
- 多个变更需要合并规范
- 维护规范文档一致性

**示例**：
```bash
/opsx:sync
```

---

#### `opsx:onboard` - 引导式入门

**用途**：通过实际操作学习 OpenSpec 工作流

**使用场景**：
- 第一次使用 OpenSpec
- 需要了解完整流程
- 团队培训

**示例**：
```bash
/opsx:onboard
```

**内容**：
- 📚 完整工作流演示
- 🎯 实际代码库操作
- 💡 最佳实践讲解

---

## 实战示例

### 示例 1：开发新功能（标准流程）

**场景**：为问题定位助手添加日志聚合功能

```bash
# 步骤 1：探索需求（可选）
/opsx:explore
# 提示：思考日志聚合的技术方案、数据结构、性能要求

# 步骤 2：创建新变更
/opsx:new
# 输入：功能名称、目标、背景信息

# 步骤 3：逐步创建工件
/opsx:continue  # 创建需求分析工件
/opsx:continue  # 创建技术设计工件
/opsx:continue  # 创建实现计划工件

# 步骤 4：实施开发
/opsx:apply
# 系统会根据实现计划逐个完成任务

# 步骤 5：验证实现
/opsx:verify
# 检查是否符合所有验收标准

# 步骤 6：归档变更
/opsx:archive
# 完成并归档此次变更
```

---

### 示例 2：快速修复（快速模式）

**场景**：修复一个明确的 Bug

```bash
# 步骤 1：创建变更并快速生成工件
/opsx:new
/opsx:ff  # 快速生成所有工件

# 步骤 2：实施修复
/opsx:apply

# 步骤 3：验证并归档
/opsx:verify
/opsx:archive
```

---

### 示例 3：并行开发多个功能

**场景**：同时开发多个独立功能

```bash
# 功能 A：日志聚合
/opsx:new  # 创建 Change A
/opsx:continue  # 创建工件...

# 功能 B：代码索引
/opsx:new  # 创建 Change B
/opsx:continue  # 创建工件...

# 功能 C：报告生成
/opsx:new  # 创建 Change C
/opsx:continue  # 创建工件...

# 分别实施
# 在 Change A 目录下
/opsx:apply

# 在 Change B 目录下
/opsx:apply

# 在 Change C 目录下
/opsx:apply

# 全部完成后批量归档
/opsx:bulk-archive
```

---

## 最佳实践

### 1. 何时使用 OpenSpec

**✅ 推荐使用**：
- 功能复杂度高（涉及多个模块）
- 需要团队协作
- 需要详细文档
- 架构级别的变更
- 不确定技术方案

**❌ 不推荐使用**：
- 简单的代码修改（如修改文案）
- 紧急热修复
- 实验性代码
- 一次性脚本

---

### 2. 工件创建建议

**使用 `opsx:continue`（推荐）**：
- 复杂功能开发
- 需要深度思考设计
- 多人协作项目
- 关键业务逻辑

**使用 `opsx:ff`**：
- 简单明确的任务
- 时间紧迫
- 已有清晰方案
- 重复性工作

---

### 3. 工件质量要求

**需求分析工件**：
- 明确目标和背景
- 列出功能需求
- 定义验收标准
- 识别约束条件

**技术设计工件**：
- 架构设计图
- 技术选型理由
- 接口定义
- 数据模型

**实现计划工件**：
- 任务分解清晰
- 优先级明确
- 依赖关系清楚
- 可执行性强

---

### 4. 验证检查清单

在执行 `opsx:verify` 前，确保：

- [ ] 所有计划任务已完成
- [ ] 代码通过测试
- [ ] 符合技术设计
- [ ] 满足验收标准
- [ ] 文档已更新
- [ ] 无遗留 TODO

---

### 5. 归档时机

**立即归档**：
- 功能完全实现
- 验证通过
- 无后续工作

**延迟归档**：
- 需要观察线上表现
- 等待用户反馈
- 计划后续优化

---

## 常见场景

### 场景 1：需求不明确

```bash
# 先探索，理清思路
/opsx:explore
# 在探索模式中：
# - 分析问题
# - 讨论方案
# - 明确需求

# 思路清晰后再创建 Change
/opsx:new
```

---

### 场景 2：中途发现设计问题

```bash
# 如果在实施过程中发现设计有问题：

# 方案 1：修改当前 Change 的工件
# 编辑设计工件，更新实现计划

# 方案 2：创建新的 Change
# 归档当前 Change（标记为部分完成）
/opsx:archive

# 创建新 Change 重新设计
/opsx:new
```

---

### 场景 3：多人协作

```bash
# 开发者 A：创建 Change 和工件
/opsx:new
/opsx:continue  # 创建所有工件

# 开发者 B：基于工件实施
/opsx:apply

# 开发者 C：验证实现
/opsx:verify

# 开发者 A：归档
/opsx:archive
```

---

### 场景 4：规范维护

```bash
# 定期同步规范
/opsx:sync

# 或在归档时自动同步
/opsx:archive  # 会提示是否同步到主规范
```

---

## 命令速查表

| 命令 | 简写 | 用途 | 使用频率 |
|------|------|------|----------|
| openspec-new-change | opsx:new | 创建新变更 | ⭐⭐⭐⭐⭐ |
| openspec-continue-change | opsx:continue | 创建下一个工件 | ⭐⭐⭐⭐⭐ |
| openspec-apply-change | opsx:apply | 实施任务 | ⭐⭐⭐⭐⭐ |
| openspec-verify-change | opsx:verify | 验证实现 | ⭐⭐⭐⭐ |
| openspec-archive-change | opsx:archive | 归档变更 | ⭐⭐⭐⭐ |
| openspec-ff-change | opsx:ff | 快速生成工件 | ⭐⭐⭐ |
| openspec-explore | opsx:explore | 探索模式 | ⭐⭐⭐ |
| openspec-sync-specs | opsx:sync | 同步规范 | ⭐⭐ |
| openspec-bulk-archive-change | opsx:bulk-archive | 批量归档 | ⭐⭐ |
| openspec-onboard | opsx:onboard | 引导入门 | ⭐ |

---

## 工作流决策树

```
开始新任务
    │
    ├─ 需求明确？
    │   ├─ 否 → /opsx:explore（探索需求）
    │   └─ 是 ↓
    │
    ├─ /opsx:new（创建变更）
    │
    ├─ 任务复杂？
    │   ├─ 是 → /opsx:continue（逐步创建工件）
    │   └─ 否 → /opsx:ff（快速生成工件）
    │
    ├─ /opsx:apply（实施开发）
    │
    ├─ /opsx:verify（验证实现）
    │
    ├─ 验证通过？
    │   ├─ 否 → 返回修复
    │   └─ 是 ↓
    │
    └─ /opsx:archive（归档变更）
```

---

## 总结

OpenSpec 规范驱动开发通过结构化的工作流程，帮助团队：

1. **提高质量**：先设计后实现，减少返工
2. **提升效率**：清晰的任务分解，减少迷茫
3. **沉淀知识**：规范文档成为项目资产
4. **促进协作**：统一的工作流程，便于交接

### 快速开始

```bash
# 第一次使用？先体验引导流程
/opsx:onboard

# 开始你的第一个 Change
/opsx:new
```

### 获取帮助

- 命令行帮助：`/help`
- 反馈问题：https://github.com/anthropics/claude-code/issues

---

**文档版本**：1.0
**更新日期**：2026-02-03
**适用版本**：Claude Code CLI
